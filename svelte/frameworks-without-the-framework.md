## 프레임워크 없는 프레임워크 : 왜 이걸 바로 생각하지 못했을까?

복잡성의 벽을 두드리지 않고서는 바닐라 js로 중요한 어플리케이션을 작성할 수 없습니다. 하지만 컴파일러는 할 수 있죠.

---

https://svelte.dev/blog/frameworks-without-the-framework

[Rich Harris](https://twitter.com/Rich_Harris), 2016년 11월 26일

> 잠깐만요, 이 새 프레임워크가 런타임이 있나요? 어, 네, 됐어요. - 2018년의 프론트엔드 개발자

우리는 사용자들에게 너무 많은 코드를 부담 지우고 있습니다. 많은 프론트엔드 개발자들이 그렇듯이 나도 이런 사실에 대해 부정적이었습니다. 100kb정도의 js를 페이지 로 드시에 가져다주면 괜찮겠다라고 생각했었죠. - [.jpg 하나 덜 쓰면 되지](https://twitter.com/miketaylr/status/227056824275333120)라면서 말이죠. 정말 중요한 건 앱이 이미 상호작용을 할 때 성능이었습니다.

그래요 내가 틀렸습니다. .js의 100kb는 .jpg의 100kb와는 다릅니다. 앱의 시작 퍼포먼스를 죽이는 건 네트워크 시간이 아닙니다. 스크립트의 파싱과 평가 시간 이었습니다. 그 시간 동안 브라우저는 완전히 반응하지 못했습니다. 모바일에서 그 수 밀리초가 엄청나게 증가합니다.

이 문제에 대해 확신하지 못한다면 [Alex Russell](https://twitter.com/slightlylate)의 트위터를 팔로우 하세요. Alex는 [근래 프레임워크 커뮤니티에서 친구를 많이 사귀진 못했지만](https://twitter.com/slightlylate/status/728355959022587905), 틀리지 않았습니다. Angular, React, 그리고 Ember([Polymer](https://polymer-library.polymer-project.org/3.0/docs/devguide/feature-overview)) 같은 프레임워크를 사용하는 것에 대해 대안을 제시하는 것은 아직 프론트엔드 세계에서 큰 관심을 끌지 못하고 있습니다. 홍보가 부족한 것도 아닙니다.

아마 이 모든 걸 다시 생각해봐야 할 것 같습니다.

### 프레임워크가 실제로 어떤 문제를 해결하는 걸까?

프레임워크가 코드의 복잡성을 관리를 더 쉽게 해 준다는 공통적인 시각이 존재합니다. 이는 프레임워크가 가상 DOM 비교 같은 기술들로 귀찮은 세부 구현사항을 추상화시켜준다는 시각입니다. 하지만 그렇지 않습니다. 프레임워크는 기껏해야 당신이 작성해야 하지만, 하지 않는 그런 코드의 복잡성을 멀리하게 해줄 뿐입니다.

React가 널리 그리고 상당히 성공적이라고 생각되는 이유는 컨셉의 복잡성을 쉽게 다루게 해주기 때문입니다. 프레임워크는 근본적으로는 생각을 구조화하는 도구에 불과합니다. 코드가 아닙니다.

가령, 프레임워크가 실제론 브라우저에서 돌아가지 않으면 어떨까요? 대신 앱을 순수한 바닐라 js로 바꿔주는 거죠, Babel이 ES2016+를 ES5로 바꿔주듯이 말이에요. 무거운 런타임에 대한 적재 비용을 낼 필요가 없는 거죠, 그리고 앱이 엄청나게 빨라질 겁니다. 앱과 브라우저 사이 추상화 계층이 없기 때문이죠.

### Svelte를 소개합니다

Svelte는 정확히 그런 일을 하는 프레임워크입니다. 컴포넌트를 HTML/CSS/JS로 작성하고([5분 내로 배울 수 있는 것들](https://v2.svelte.dev/guide)도 함께), 그 결과물을 매우 작은 단일 js 모듈로 만듭니다. 컴포넌트 템플릿을 정적으로 분석함으로써 브라우저가 가능한 한 적은 일을 하게 될 거라고 확신합니다.

[TodoMVC의 Svelte 구현](https://svelte-todomvc.surge.sh/)은 3.6kb로 압축될 수 있습니다. 그 어떤 코드도 없는 React와 ReactDOM은 45kb로 압축됩니다. 아무것도 하지 않는 React가 상호작용을 하는 Svelte TodoMVC에 비해 10배나 긴 평가 시간을 잡아먹습니다.

앱이 올라가고 돌아갈 때 [js 프레임워크 벤치마크](https://github.com/krausest/js-framework-benchmark)에 따르면 Svelte는 사기적으로 빠릅니다. Vue보다 빠르죠. Angular, Ember, Reactive, Preact, Riot, 또는 Mithril 같은 것보다 빠릅니다. Inferno와는 경잴할 만 합니다. Inferno는 아마 지금 세상에서 제일 빠른 UI 프레임워크일 거예요, 지금은, 왜냐하면 [Dominic Gannaway](https://twitter.com/trueadm)이 마법사기 때문이죠. (Svelte는 엘레멘트를 삭제할 때 느립니다. 해결하려고 [작업 중](https://github.com/sveltejs/svelte/issues/26)입니다.)

바닐라 js만큼 빠르다는 말은 이치에 맞습니다. 바닐라 js거든요. 작성할 필요가 없는 그냥 바닐라 js인거죠.

### 하지만 그 게 중요한 건 아닙니다.

음, 그렇죠 퍼포먼스는 중요합니다. 근데 이 접근방식에 있어 가장 흥미로운 것은 웹 개발에 있어 가장 골치 아픈 문제를 마침내 해결했다는 겁니다.

코드간 상호 운용성(interoperability)에 대해 생각해보세요. `npm install cool-calendar-widget`을 원하고 앱에 쓰고 싶은가요? `cool-calendar-widget`이 React나 Angular에서 개발 되었다면 이전에는 위젯이 목표로 한 프레임워크(정확한 버전의)만 그 위젯을 사용할 수 있었습니다. 안타까운 일입니다. 하지만 위젯의 작성자가 Svelte를 썼었다면? 앱은 당신이 좋아하는 무슨 기술을 쓰든 그 위젯을 사용할 수 있습니다.

[코드 스플리팅](https://twitter.com/samccone/status/797528710085652480)은 어떨까요? 사용자가 최초 뷰에 필요한 것만 로드하고 나머지를 나중에 로드한다니, 정말 멋진 생각입니다. 하지만 문제가 있죠. 100개 대신 하나의 React 컴포넌트를 최초로 로드한다고 해도, 결국 여전히 React를 사용하고 있습니다. Svelte와 함께라면 코드 스플리팅을 더욱 효율적으로 개선할 수 있습니다. 프레임워크가 컴포넌트에 포함되어있고 컴포넌트가 무척이나 작기 때문이죠.

마지막으로 내가 오픈소스 메인테이네이너로서 가끔씩 씨름해온 것이 있는데, 바로 사용자가 항상 그들의 기능이 우선 되길 원한다는 겁니다. 그리곤 그 기능의 비용(그 기능이 필요 없는 사람들도 있으니까요)을 간과합니다. 프레임워크 작성자는 반드시 프로젝트의 장기적인 건강과 사용자의 욕구 충족의 사이에서 균형을 유지해야 합니다. 굉장히 어려운 일입니다. 점진적으로 부풀어 오르는 그 결과는 예상하기 어렵습니다. 그 기능이 충분히 중요하지 않다고 열정적으로 당신의 도구를 전도하고 다니는 사람에게 말하는 것도 굉장히 힘든 일입니다. 하지만 Svelte의 접근법이라면 그 기능을 사용하지 않는 사람들에 대한 부담 없이 많은 기능을 추가할 수 있습니다. 필요하지 않다면 그 기능들을 구현한 코드가 컴파일러에 의해 생성되지 않을 것이기 때문입니다.

### 우리는 이제 시작하려고 합니다.

Svelte는 굉장히 새로운 것이고 할 것이 많이 남아있습니다. 빌드 툴 통합도 해야하고, 서버사이드 렌더링도 추가하고, 핫 리로딩도 추가하고, 트랜지션도 추가하고, 문서도 추가하고 예제도 추가해야합니다. 스타터 킷도 있어야겠죠. 그 외에도 많습니다.

하지만 그런에도 이미 훌륭한 컴포넌트를 Svelte와 만들 수 있습니다. 그래서 바로 안정화된 1.0.0를 릴리즈했습니다. [이 가이드를 읽고](https://v2.svelte.dev/guide), [REPL](https://svelte.dev/repl/hello-world?version=3.44.3)을 사용해보세요. 그리고 프론트엔드 개발의 다음 세대 시작을 돕기 위해 [GitHub](https://github.com/sveltejs/svelte)으로 넘어오세요.
